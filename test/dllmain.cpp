/**
 * @see https://docs.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/author-coclasses#add-helper-types-and-functions 
 * @see https://docs.microsoft.com/ko-kr/windows/win32/com/registering-com-servers
 * @see https://docs.microsoft.com/en-us/windows/win32/sysinfo/structure-of-the-registry
 */
#include <filesystem>
#include <sdkddkver.h>

#include <Windows.h>
#include <mfapi.h>
#include <mferror.h>
#include <mfidl.h>
#include <mfreadwrite.h>
#include <spdlog/sinks/basic_file_sink.h>
#include <spdlog/sinks/stdout_sinks.h>
#include <spdlog/spdlog.h>
#include <winrt/Windows.System.Threading.h>
#include <winrt/base.h>

namespace fs = std::filesystem;

#define _HIDDEN_
#ifdef _WINDLL
#define _INTERFACE_ __declspec(dllexport)
#else
#define _INTERFACE_ // __declspec(dllimport)
#endif

// These files will be generated by MIDL through CMake. Simply #include to use those code
//#include "MFT0.h"
//#include "MFT0_i.c"
//#include "MFT0_p.c"
//#include "media_winrt.h"

using namespace std;
using winrt::Windows::Foundation::IAsyncAction;

#if !defined(SOURCE_VERSION)
static_assert(false, "macro SOURCE_VERSION is not provided");
#endif

void get_class_id(GUID& output) noexcept {
    output = {}; // = CLSID_Mft0;
}

volatile ULONG g_ref_count = 0;
HMODULE g_module = NULL;

extern "C" {

BOOL __stdcall DllMain(HINSTANCE hinst, DWORD reason, void*) {
    if (reason == DLL_PROCESS_ATTACH) {
        g_module = static_cast<HMODULE>(hinst);
        DisableThreadLibraryCalls(hinst);
    }
    return TRUE;
}

_INTERFACE_ ULONG __stdcall DllAddRef() {
    return _InterlockedIncrement(&g_ref_count);
}
_INTERFACE_ ULONG __stdcall DllRelease() {
    return _InterlockedDecrement(&g_ref_count);
}

__control_entrypoint(DllExport) HRESULT __stdcall DllCanUnloadNow() {
    return (g_ref_count == 0) ? S_OK : S_FALSE;
}

} // extern "C"

//auto make_logger(const char* name, FILE* fout) {
//    using sink_type = spdlog::sinks::stdout_sink_base<spdlog::details::console_nullmutex>;
//    return std::make_unique<spdlog::logger>(name, std::make_shared<sink_type>(fout));
//}

/// @see https://docs.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/author-coclasses
/// @note `winrt::implements` template alreay implements QueryInterface, AddRef, Release...
class noop_unknown_t : public winrt::implements<noop_unknown_t, IUnknown> {
    std::unique_ptr<spdlog::logger> stream = nullptr;
    UINT32 state = 0;

  public:
    noop_unknown_t() noexcept {
        using sink_type = spdlog::sinks::stdout_sink_base<spdlog::details::console_nullmutex>;
        const char* name = "inproc";
        FILE* fout = stdout;
        stream = std::make_unique<spdlog::logger>(name, std::make_shared<sink_type>(fout));
        stream->set_level(spdlog::level::debug);
    }

  private:
    HRESULT STDMETHODCALLTYPE SetState(UINT32 _state) noexcept {
        stream->debug("{}", __FUNCTION__);
        this->state = _state;
        return S_OK;
    }
    HRESULT STDMETHODCALLTYPE GetState(UINT* ptr) noexcept {
        stream->debug("{}", __FUNCTION__);
        if (ptr == nullptr)
            return E_POINTER;
        *ptr = this->state;
        return S_OK;
    }
};

class class_factory_t : public winrt::implements<class_factory_t, IClassFactory> {
  public:
    class_factory_t() noexcept {
        DllAddRef();
    }

    ~class_factory_t() noexcept {
        DllRelease();
    }

  private:
    //ULONG ref_count;

    //IFACEMETHODIMP QueryInterface(REFIID riid, void** ppv) {
    //    if (ppv == NULL)
    //        return E_POINTER;
    //    if (riid == IID_IUnknown)
    //        *ppv = static_cast<IUnknown*>(this);
    //    else if (riid == IID_IClassFactory)
    //        *ppv = static_cast<IClassFactory*>(this);
    //    else {
    //        *ppv = nullptr;
    //        return E_NOINTERFACE;
    //    }
    //    AddRef();
    //    return S_OK;
    //}

    //IFACEMETHODIMP_(ULONG) AddRef() {
    //    return _InterlockedIncrement(&ref_count);
    //}

    //IFACEMETHODIMP_(ULONG) Release() {
    //    const long count = _InterlockedDecrement(&ref_count);
    //    if (count == 0)
    //        delete this;
    //    return count;
    //}

    IFACEMETHODIMP CreateInstance(IUnknown* ptr, REFIID riid, void** ppv) {
        if (ptr != nullptr)
            return CLASS_E_NOAGGREGATION;
        auto instance = winrt::make<noop_unknown_t>();
        return instance->QueryInterface(riid, ppv);
    }

    IFACEMETHODIMP LockServer(BOOL lock) {
        if (lock)
            DllAddRef();
        else
            DllRelease();
        return S_OK;
    }
};

extern "C" {
_Check_return_ STDAPI DllGetClassObject(_In_ REFCLSID rclsid, _In_ REFIID riid, _Outptr_ LPVOID FAR* ppv) {
    *ppv = NULL;
    if (false) { //IsEqualGUID(rclsid, CLSID_Mft0)) {
        //IClassFactory* factory = new (std::nothrow) class_factory_t();
        //if (factory == nullptr)
        //    return E_OUTOFMEMORY;
        //HRESULT hr = factory->QueryInterface(riid, ppv);
        //factory->Release();
        //return hr;
        return winrt::make<class_factory_t>()->QueryInterface(riid, ppv);
    }
    return CLASS_E_CLASSNOTAVAILABLE;
}
} // extern "C"

std::string w2mb(std::wstring_view in);
std::string to_guid_string(const GUID& guid);

void get_module_path(std::wstring& path) noexcept {
    WCHAR buf[MAX_PATH]{};
    DWORD buflen = GetModuleFileNameW(g_module, buf, MAX_PATH);
    path = {buf, buflen};
}
void get_module_path(std::string& path) noexcept {
    CHAR buf[MAX_PATH]{};
    DWORD buflen = GetModuleFileNameA(g_module, buf, MAX_PATH);
    path = {buf, buflen};
}

struct prop_variant : PROPVARIANT {
    prop_variant() noexcept = default;
    ~prop_variant() noexcept {
        clear();
    }
    void clear() noexcept {
        WINRT_VERIFY_(S_OK, ::PropVariantClear(this));
    }
};

struct registry_traits {
    using type = HKEY;

    static void close(type value) noexcept {
        WINRT_VERIFY_(ERROR_SUCCESS, ::RegCloseKey(value));
    }
    static constexpr type invalid() noexcept {
        return HKEY{nullptr};
    }
};
using registry_key = winrt::handle_type<registry_traits>;

uint32_t get_class_context() noexcept {
    return CLSCTX_INPROC_SERVER;
}

/**
 * @brief Generate HKEY path for DllRegisterServer, DllUnregisterServer
 * 
 * @param context CLSCTX_INPROC_SERVER, CLSCTX_LOCAL_SERVER
 * @return std::wstring "SOFTWARE\Classes\CLSID\{CLSID}\InprocServer32"
 * 
 * @see DllRegisterServer
 * @see DllUnregisterServer
 * @see https://docs.microsoft.com/en-us/windows/win32/com/localserver32
 * @see https://docs.microsoft.com/en-us/windows/win32/com/inprocserver32
 */
std::wstring make_server_key_path(const CLSID& clsid, [[maybe_unused]] CLSCTX context = CLSCTX_INPROC_SERVER) {
    std::wstring key_path{LR"(SOFTWARE\Classes\CLSID\{????????-????-????-????-????????????})"};
    if (::StringFromGUID2(clsid, key_path.data() + 23, 39) == 0)
        throw std::runtime_error{"Buffer for GUID is not enough"};

    switch (context) {
    case CLSCTX_LOCAL_SERVER:
        key_path += LR"(\LocalServer32)";
        break;
    case CLSCTX_INPROC_SERVER:
    default:
        key_path += LR"(\InprocServer32)";
    }
    return key_path;
}

struct class_registration_t final {
    CLSID clsid{};
    std::wstring fpath{};
    spdlog::logger& logger;

  public:
    class_registration_t(spdlog::logger& logger) : logger{logger} {
        get_class_id(clsid);
        logger.info("CLSID: {}", to_guid_string(clsid));
        get_module_path(fpath);
        logger.info("module: {}", fs::path{fpath}.generic_u8string());
    }

    HRESULT create_key(registry_key& key, HKEY hkey) const noexcept {
        const std::wstring key_path = make_server_key_path(clsid);
        return ::RegCreateKeyExW(hkey, key_path.c_str(), 0, nullptr, 0, KEY_WRITE, nullptr, key.put(), nullptr);
    }

    HRESULT set_module_path(HKEY hkey) const noexcept {
        const auto ec = ::RegSetValueExW(hkey, nullptr, 0, REG_SZ, //
                                         reinterpret_cast<BYTE const*>(fpath.c_str()),
                                         static_cast<uint32_t>((fpath.size() + 1) * sizeof(wchar_t)));
        if (SUCCEEDED(ec)) {
            const std::wstring key_path = make_server_key_path(clsid);
            logger.info("RegKey(HKEY_CURRENT_USER): {}", w2mb(key_path));
        }
        return ec;
    }
};

extern "C" {
/**
 * @brief `regsvr32` will report from this function's return * 
 * @note We can't use WinRT in this routine
 */
STDAPI DllRegisterServer() {
    auto logger = spdlog::basic_logger_st("com", "register.log", true);
    logger->set_level(spdlog::level::debug);
    logger->info("version: {}", SOURCE_VERSION);
    logger->info("commit: {}", SOURCE_COMMIT_ID);
    logger->info("timestamp: {}", SOURCE_TIMESTAMP);

    class_registration_t registration{*logger};
    registry_key key{};
    if (auto ec = registration.create_key(key, HKEY_CURRENT_USER); FAILED(ec))
        return winrt::impl::hresult_from_win32(ec);

    ::RegDeleteValueW(key.get(), nullptr);
    logger->info("RegKey(HKEY_CURRENT_USER): {}", "deleted");

    if (auto ec = registration.set_module_path(key.get()); FAILED(ec))
        return winrt::impl::hresult_from_win32(ec);
    return S_OK;
}

/**
 * @brief `regsvr32 /u` will report from this function's return
 * @note We can't use WinRT in this routine
 */
STDAPI DllUnregisterServer() {
    auto logger = spdlog::basic_logger_st("com", "unregister.log", true);
    logger->set_level(spdlog::level::debug);
    logger->info("version: {}", SOURCE_VERSION);

    class_registration_t registration{*logger};
    registry_key key{};
    if (auto ec = registration.create_key(key, HKEY_CURRENT_USER); FAILED(ec))
        return winrt::impl::hresult_from_win32(ec);

    ::RegDeleteValueW(key.get(), nullptr);
    logger->info("RegKey(HKEY_CURRENT_USER): {}", "deleted");
    return S_OK;
}

} // extern "C"
